{"version":3,"file":"index.min.js","sources":["../src/index.ts"],"sourcesContent":["/**\r\n * The following three expressions are strings because they are used\r\n * as segments in paths, not as individual expressions.\r\n */\r\n\r\n// replaces wildcards\r\nconst MATCH_ALL = '[^/?#]*';\r\n// replaces parameters\r\nconst CATCH_ALL = '([^/?#]+)';\r\n\r\n// only matches the slash if nothing follows\r\n// (i. e. optional trailing slash)\r\n// appended to the end of the expression\r\nconst MATCH_TRAILING_SLASH = '(?:[/]?(?=$))?';\r\n\r\n/**\r\n * The following two expressions are RegExp instances because they are used\r\n * to find expressions that should be replaced.\r\n */\r\n\r\n// matches '**'\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\n// matches ':param' and captures 'param'\r\nconst PARAMETER_PATTERN = /:([^\\/?#]+)/g;\r\n\r\n/**\r\n * Extract the keys in a path declaration.\r\n * @example\r\n * parse('/:a/:b/:c'); // => ['a', 'b', 'c']\r\n * \r\n * @param path The path declaration\r\n */\r\nexport const parse = (\r\n  path: string\r\n): string[] => {\r\n  let keys: string[] = [];\r\n  let match;\r\n  while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n    keys.push(match[1]);\r\n  }\r\n  return keys;\r\n}\r\n\r\n/**\r\n * Create a regular expression from a path with (optional) encoded parameter keys in it.\r\n * `exact` determines if the resulting expression should match\r\n * any superset of the given path or only match equal segment-length paths.\r\n * \r\n * @example\r\n * compile('/:a').test('/a'); // => true\r\n * compile('/:a').test('/a/b'); // => true\r\n * compile(':a', true).test('/a'); // => true\r\n * compile(':a', true).test('/a/b'); // => false\r\n * \r\n * @param path The path declaration\r\n * @param exact If `true`, the resulting expression will only match\r\n * 1:1 (instead of matching any superset of the given path).\r\n */\r\nexport const compile = (\r\n  path: string,\r\n  exact: boolean = false\r\n): RegExp => (\r\n  new RegExp(\r\n    '^' +\r\n    path\r\n      // Replace '**' with a matching group\r\n      .replace(WILDCARD_PATTERN, MATCH_ALL)\r\n      // Replace ':key' with a catching group\r\n      .replace(PARAMETER_PATTERN, CATCH_ALL)\r\n      // Match an optional trailing slash\r\n    + MATCH_TRAILING_SLASH\r\n    // If exact, only match completely\r\n    + (exact ? '$' : ''),\r\n    'i'\r\n  )\r\n);\r\n\r\n/**\r\n * Retrieve the values embedded in a string using a compiled regular expression.\r\n * \r\n * @example\r\n * const pattern = compile('/:a');\r\n * execute(pattern, '/value'); // => ['value']\r\n * \r\n * @param pattern The pattern returned from `compile`\r\n * @param path The live path\r\n */\r\nexport const execute = (\r\n  pattern: RegExp,\r\n  path: string\r\n): string[] => (\r\n  (pattern.exec(path) || []).slice(1)\r\n);\r\n\r\ntype Tuple<K, V> = [K, V];\r\n\r\nconst zip = (\r\n  a: any[],\r\n  b: any[]\r\n): Tuple<any, any>[] => (\r\n  a.map((v, i): Tuple<any, any> => [v, b[i]])\r\n);\r\n\r\n/**\r\n * Convert an array of keys and an array of values into a Map.\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * map(keys, values); // => Map {'a' => 'some', 'b' => 'path'}\r\n * \r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const map = (\r\n  keys: string[],\r\n  values: string[]\r\n): Map<string,string> => (\r\n  new Map(zip(keys, values))\r\n);\r\n\r\ntype Dictionary<T> = { [key: string]: T };\r\n\r\n/**\r\n * Convert an array of keys and an array of values into a plain object.\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * object(keys, values); // => { a: 'some', b: 'path' }\r\n * \r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const object = (\r\n  keys: string[],\r\n  values: string[]\r\n): Dictionary<string> => (\r\n  keys.reduce(\r\n    (acc, key, i) => {\r\n      acc[key] = values[i];\r\n      return acc;\r\n    },\r\n    {} as Dictionary<string>\r\n  )\r\n);\r\n\r\ntype Reducer = (keys: string[], values: string[]) => any;\r\n\r\n/**\r\n * Parse and compile a path to a function that extracts values from a given string.\r\n * @example\r\n * import { object, map } from 'expressionist';\r\n * \r\n * const toObject = program('/:a/:b', object);\r\n * toObject('/some/path'); // => { a: 'some', b: 'path' }\r\n * \r\n * const toMap = program('/:a/:b', map);\r\n * toMap('/some/path'); // => Map {'a' => 'some', 'b' => 'path'}\r\n * \r\n * @param path Any path\r\n * @param exact Execute on complete matches\r\n */\r\nexport const program = (\r\n  path: string,\r\n  reducer: Reducer = object,\r\n  exact: boolean = false\r\n) => {\r\n  const keys = parse(path);\r\n  const pattern = compile(path, exact);\r\n  return (string: string) => reducer(\r\n    keys,\r\n    execute(pattern, string)\r\n  );\r\n}\r\n"],"names":["WILDCARD_PATTERN","PARAMETER_PATTERN","parse","path","match","keys","exec","push","compile","exact","RegExp","replace","execute","pattern","slice","map","values","Map","a","b","v","i","zip","object","reduce","acc","key","program","reducer","string"],"mappings":"AAMA,MAeMA,EAAmB,QAGnBC,EAAoB,eASbC,EACXC,IAEA,IACIC,EADAC,KAEJ,KAAiD,OAAzCD,EAAQH,EAAkBK,KAAKH,KACrCE,EAAKE,KAAKH,EAAM,IAElB,OAAOC,GAkBIG,EAAU,CACrBL,EACAM,GAAiB,QAEbC,OACF,IACAP,EAEGQ,QAAQX,EA7DG,WA+DXW,QAAQV,EA7DG,aAKW,kBA4DtBQ,EAAQ,IAAM,IACjB,KAcSG,EAAU,CACrBC,EACAV,KAECU,EAAQP,KAAKH,QAAaW,MAAM,GAuBtBC,EAAM,CACjBV,EACAW,QAEIC,IAtBM,EACVC,EACAC,IAEAD,EAAEH,IAAI,CAACK,EAAGC,KAAwBD,EAAGD,EAAEE,KAkB/BC,CAAIjB,EAAMW,IAgBPO,EAAS,CACpBlB,EACAW,IAEAX,EAAKmB,OACH,CAACC,EAAKC,EAAKL,KACTI,EAAIC,GAAOV,EAAOK,GACXI,OAsBAE,EAAU,CACrBxB,EACAyB,EAAmBL,EACnBd,GAAiB,KAEjB,MAAMJ,EAAOH,EAAMC,GACbU,EAAUL,EAAQL,EAAMM,GAC9B,OAAQoB,GAAmBD,EACzBvB,EACAO,EAAQC,EAASgB"}