{"version":3,"file":"index.min.js","sources":["../src/index.ts"],"sourcesContent":["const MATCH_ALL = '[^/?#]*';\r\n\r\nconst CATCH_ALL = '([^/?#]+)';\r\n\r\n// optional trailing slash\r\n// only matches the slash if nothing follows\r\nconst MATCH_TRAILING_SLASH = '(?:[/]?(?=$))?';\r\n\r\n// implements '**' as a wildcard\r\nconst WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\n// matches ':param' and captures 'param'\r\nconst PARAMETER_PATTERN = /:([^\\/?#]+)/g;\r\n\r\nexport const parse = (\r\n  path: string\r\n): string[] => {\r\n  let keys: string[] = [];\r\n  let match;\r\n  while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n    keys.push(match[1]);\r\n  }\r\n  return keys;\r\n}\r\n\r\nexport const compile = (\r\n  path: string,\r\n  exact: boolean = false\r\n): RegExp => (\r\n  new RegExp(\r\n    '^' +\r\n    path\r\n      // Remove hash\r\n      .split('#')[0]\r\n      // Remove query\r\n      .split('?')[0]\r\n      // Replace '**' with a matching group\r\n      .replace(WILDCARD_PATTERN, MATCH_ALL)\r\n      // Replace ':key' with a catching group\r\n      .replace(PARAMETER_PATTERN, CATCH_ALL)\r\n      // Match an optional trailing slash\r\n    + MATCH_TRAILING_SLASH\r\n    // If exact, only match completely\r\n    + (exact ? '$' : ''),\r\n    'i'\r\n  )\r\n);\r\n\r\n/**\r\n * Retrieve the values embedded in a live path.\r\n * @param pattern The pattern returned from `compile` \r\n * @param path The live path\r\n */\r\nexport const execute = (\r\n  pattern: RegExp,\r\n  path: string\r\n): string[] => (\r\n  (pattern.exec(path) || []).slice(1)\r\n);\r\n\r\nconst zip = (\r\n  a: any[],\r\n  b: any[]\r\n): any[2][] => (\r\n  a.map((v, i) => [v, b[i]])\r\n);\r\n\r\n/**\r\n * Convert an array of keys and an array of values into a Map.\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const map = (\r\n  keys: string[],\r\n  values: string[]\r\n): Map<string,string> => (\r\n  new Map(zip(keys, values))\r\n);\r\n\r\n/**\r\n * Convert an array of keys and an array of values into a plain object.\r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const object = (\r\n  keys: string[],\r\n  values: string[]\r\n): { [key: string]: string } => (\r\n  keys.reduce(\r\n    (acc, key, i) => {\r\n      acc[key] = values[i];\r\n      return acc;\r\n    },\r\n    {} as { [key: string]: string }\r\n  )\r\n);\r\n\r\ntype Reducer = (keys: string[], values: string[]) => any;\r\n\r\n/**\r\n * Parse and compile a path to a function that extracts values from a given string.\r\n * @param path Any path\r\n * @param exact Execute on complete matches\r\n */\r\nexport const program = (\r\n  path: string,\r\n  reducer: Reducer = object,\r\n  exact: boolean = false\r\n) => {\r\n  const keys = parse(path);\r\n  const pattern = compile(path, exact);\r\n  return (str: string) => reducer(\r\n    keys,\r\n    execute(pattern, str)\r\n  );\r\n}\r\n\r\nexport default program;"],"names":["MATCH_ALL","CATCH_ALL","MATCH_TRAILING_SLASH","WILDCARD_PATTERN","PARAMETER_PATTERN","parse","path","match","keys","exec","push","compile","exact","RegExp","split","replace","execute","pattern","slice","zip","a","b","map","v","i","values","Map","object","reduce","acc","key","program","reducer","str"],"mappings":"AAAA,MAAMA,UAAY,UAEZC,UAAY,YAIZC,qBAAuB,iBAGvBC,iBAAmB,QAGnBC,kBAAoB,eAEbC,MACXC,IAEA,IACIC,EADAC,KAEJ,KAAiD,OAAzCD,EAAQH,kBAAkBK,KAAKH,KACrCE,EAAKE,KAAKH,EAAM,IAElB,OAAOC,GAGIG,QAAU,CACrBL,EACAM,GAAiB,QAEbC,OACF,IACAP,EAEGQ,MAAM,KAAK,GAEXA,MAAM,KAAK,GAEXC,QAAQZ,iBArCG,WAuCXY,QAAQX,kBAAmBH,WAjCL,kBAqCtBW,EAAQ,IAAM,IACjB,KASSI,QAAU,CACrBC,EACAX,KAECW,EAAQR,KAAKH,QAAaY,MAAM,GAG7BC,IAAM,CACVC,EACAC,IAEAD,EAAEE,IAAI,CAACC,EAAGC,KAAOD,EAAGF,EAAEG,KAQXF,IAAM,CACjBd,EACAiB,QAEIC,IAAIP,IAAIX,EAAMiB,IAQPE,OAAS,CACpBnB,EACAiB,IAEAjB,EAAKoB,OACH,CAACC,EAAKC,EAAKN,KACTK,EAAIC,GAAOL,EAAOD,GACXK,OAaAE,QAAU,CACrBzB,EACA0B,EAAmBL,OACnBf,GAAiB,KAEjB,MAAMJ,EAAOH,MAAMC,GACbW,EAAUN,QAAQL,EAAMM,GAC9B,OAAQqB,GAAgBD,EACtBxB,EACAQ,QAAQC,EAASgB"}