{"version":3,"file":"index.min.js","sources":["../src/constants.ts","../src/parse.ts","../src/compile.ts","../src/execute.ts","../src/map.ts","../src/object.ts","../src/program.ts"],"sourcesContent":["/**\r\n * Matches anything until the next '/', '?' or '#'.\r\n * Replacement for wildcards in path declarations when building a RegExp.\r\n */\r\nexport const MATCH_ALL = '[^/?#]*';\r\n\r\n/**\r\n * Captures anything until the next '/', '?' or '#'.\r\n * Replacement for parameters in path declarations when building a RegExp.\r\n */\r\nexport const CATCH_ALL = '([^/?#]+)';\r\n\r\n/**\r\n * Matches an optional trailing '/', if it is not followed by anything.\r\n * Appended to the end of path declarations when building a RegExp.\r\n * \r\n * Notes:\r\n * - Does nothing on its own\r\n * - Does nothing without a trailing '$'\r\n * \r\n * @example\r\n * const pattern = new RegExp('^/abc' + MATCH_TRAILING_SLASH + '$');\r\n * pattern.test('/abc'); // => true\r\n * pattern.test('/abc/'); // => true\r\n * pattern.test('/abc/def'); // => false\r\n * \r\n */\r\nexport const MATCH_TRAILING_SLASH = '(?:[/]?(?=$))?';\r\n\r\n/**\r\n * Matches an optional query string.\r\n */\r\nexport const MATCH_TRAILING_QUERY = '(?:\\\\?.*)?';\r\n\r\n/**\r\n * Matches an optional hash string.\r\n */\r\nexport const MATCH_TRAILING_HASH = '(?:#.*)?';\r\n\r\n/**\r\n * Matches '**'.\r\n * \r\n * Determines where to swap in a match-all pattern.\r\n */\r\nexport const WILDCARD_PATTERN = /\\*\\*/g;\r\n\r\n/**\r\n * Matches ':param' and captures 'param'.\r\n * \r\n * Determines where to swap in a catch-all pattern, or\r\n * extracts parameter names from a path.\r\n */\r\nexport const PARAMETER_PATTERN = /:([^\\/?#]+)/g;\r\n","import { PARAMETER_PATTERN } from './constants';\r\n\r\n/**\r\n * Extract the keys in a path declaration.\r\n * @example\r\n * parse('/:a/:b/:c'); // => ['a', 'b', 'c']\r\n * \r\n * @param path A path declaration\r\n */\r\nexport const parse = (\r\n  path: string\r\n): string[] => {\r\n  let keys: string[] = [];\r\n  let match;\r\n  while ((match = PARAMETER_PATTERN.exec(path)) != null) {\r\n    keys.push(match[1]);\r\n  }\r\n  return keys;\r\n}\r\n","import {\r\n  MATCH_ALL,\r\n  CATCH_ALL,\r\n  WILDCARD_PATTERN,\r\n  PARAMETER_PATTERN,\r\n  MATCH_TRAILING_SLASH,\r\n  MATCH_TRAILING_QUERY,\r\n  MATCH_TRAILING_HASH\r\n} from './constants';\r\n\r\n/**\r\n * Create a regular expression from a path with (optional) encoded parameters in it.\r\n * `exact` determines if the resulting expression should match\r\n * any superset of the given path or only match equal segment-length paths.\r\n * \r\n * @example\r\n * // not exact\r\n * compile('/:a').test('/b'); // => true\r\n * compile('/:a').test('/a/b'); // => true\r\n * // exact\r\n * compile('/:a', true).test('/a'); // => true\r\n * compile('/:a', true).test('/a/b'); // => false\r\n * \r\n * @param path A path declaration\r\n * @param exact If `true`, the resulting expression will only match\r\n * 1:1 (instead of matching any superset of the given path).\r\n */\r\nexport const compile = (\r\n  path: string,\r\n  exact: boolean = false\r\n): RegExp => (\r\n  new RegExp(\r\n    '^' +\r\n    path\r\n      // Replace '**' with a matching group\r\n      .replace(WILDCARD_PATTERN, MATCH_ALL)\r\n      // Replace ':key' with a catching group\r\n      .replace(PARAMETER_PATTERN, CATCH_ALL)\r\n      // Match an optional trailing slash\r\n    + MATCH_TRAILING_SLASH\r\n    // If exact, only match completely\r\n    + (\r\n      exact\r\n        ? MATCH_TRAILING_QUERY + MATCH_TRAILING_HASH + '$'\r\n        : ''\r\n      ),\r\n    'i'\r\n  )\r\n);\r\n","/**\r\n * Retrieve the values embedded in a string using a\r\n * regular expression obtained from `compile`.\r\n * \r\n * @example\r\n * const pattern = compile('/:a');\r\n * execute(pattern, '/value'); // => ['value']\r\n * \r\n * @param pattern The pattern returned from `compile`\r\n * @param path The live path\r\n */\r\nexport const execute = (\r\n  pattern: RegExp,\r\n  path: string\r\n): string[] => (\r\n  (pattern.exec(path) || []).slice(1)\r\n);\r\n","const zip = <K, V>(\r\n  a: K[],\r\n  b: V[]\r\n) => (\r\n  a.map((v, i): [K, V] => [v, b[i]])\r\n);\r\n\r\n/**\r\n * Convert an array of keys and an array of values into a Map.\r\n * \r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * map(keys, values); // => Map {'a' => 'some', 'b' => 'path'}\r\n * \r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const map = (\r\n  keys: string[],\r\n  values: string[]\r\n): Map<string, string> => (\r\n  new Map(zip(keys, values))\r\n);\r\n","/**\r\n * Convert an array of keys and an array of values into a plain object.\r\n * @example\r\n * const keys = parse('/:a/:b');\r\n * const pattern = compile('/:a/:b');\r\n * const values = execute(pattern, '/some/path');\r\n * object(keys, values); // => { a: 'some', b: 'path' }\r\n * \r\n * @param keys The keys returned from `parse`\r\n * @param values The values returned from `execute`\r\n */\r\nexport const object = (\r\n  keys: string[],\r\n  values: string[]\r\n): { [key: string]: string } => (\r\n  keys.reduce(\r\n    (acc, key, i) => {\r\n      acc[key] = values[i];\r\n      return acc;\r\n    },\r\n    {} as { [key: string]: string }\r\n  )\r\n);\r\n","import { parse } from './parse';\r\nimport { compile } from './compile';\r\nimport { execute } from './execute';\r\n\r\ntype Reducer<T> = (keys: string[], values: string[]) => T;\r\ntype Executable<T> = (string: string) => T;\r\n\r\n/**\r\n * Parse and compile a path to a function that extracts values from a given string.\r\n * \r\n * @example\r\n * import { object, map } from 'expressionist';\r\n * \r\n * const toObject = program('/:a/:b', object);\r\n * toObject('/some/path'); // => { a: 'some', b: 'path' }\r\n * \r\n * const toMap = program('/:a/:b', map);\r\n * toMap('/some/path'); // => Map {'a' => 'some', 'b' => 'path'}\r\n * \r\n * @param path A path declaration\r\n * @param exact Execute on complete matches\r\n */\r\nexport const program = <T>(\r\n  path: string,\r\n  reducer: Reducer<T>,\r\n  exact: boolean = false\r\n): Executable<T> => {\r\n  const keys = parse(path);\r\n  const pattern = compile(path, exact);\r\n  return (string: string) => reducer(\r\n    keys,\r\n    execute(pattern, string)\r\n  );\r\n}\r\n"],"names":["WILDCARD_PATTERN","PARAMETER_PATTERN","parse","path","match","keys","exec","push","compile","exact","RegExp","replace","MATCH_TRAILING_QUERY","execute","pattern","slice","map","values","Map","a","b","v","i","zip","object","reduce","acc","key","program","reducer","string"],"mappings":"AAIA,MAwCaA,EAAmB,QAQnBC,EAAoB,eC3CpBC,EACXC,IAEA,IACIC,EADAC,KAEJ,KAAiD,OAAzCD,EAAQH,EAAkBK,KAAKH,KACrCE,EAAKE,KAAKH,EAAM,IAElB,OAAOC,GCUIG,EAAU,CACrBL,EACAM,GAAiB,QAEbC,OACF,IACAP,EAEGQ,QAAQX,EF/BU,WEiClBW,QAAQV,EF3BU,aAiBW,kBEe9BQ,EACIG,sBACA,IAEN,KCnCSC,EAAU,CACrBC,EACAX,KAECW,EAAQR,KAAKH,QAAaY,MAAM,GCItBC,EAAM,CACjBX,EACAY,QAEIC,IAvBM,EACVC,EACAC,IAEAD,EAAEH,IAAI,CAACK,EAAGC,KAAeD,EAAGD,EAAEE,KAmBtBC,CAAIlB,EAAMY,ICZPO,EAAS,CACpBnB,EACAY,IAEAZ,EAAKoB,OACH,CAACC,EAAKC,EAAKL,KACTI,EAAIC,GAAOV,EAAOK,GACXI,OCIAE,EAAU,CACrBzB,EACA0B,EACApB,GAAiB,KAEjB,MAAMJ,EAAOH,EAAMC,GACbW,EAAUN,EAAQL,EAAMM,GAC9B,OAAQqB,GAAmBD,EACzBxB,EACAQ,EAAQC,EAASgB"}